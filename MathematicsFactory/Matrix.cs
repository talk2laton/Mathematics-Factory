using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MathematicsFactory
{
    public class Matrix<T> : IEnumerable<T> where T : IComparable<T>, ITranscedentals<T>, IArithmetics<T>
    {
        #region Fields and Properties
        /// <summary>
        /// 
        /// </summary>
        public int Rows { get { return rows; } }

        /// <summary>
        /// 
        /// </summary>
        public int Cols { get { return cols; } }

        /// <summary>
        /// 
        /// </summary>
        public int Numel { get { return cols * rows; } }

        /// <summary>
        /// A collection of Lower and Upper Triangular Matrix Generated by LU factorization methods
        /// </summary>
        public Matrix<T> L_lu { get; protected set; } = null;

        /// <summary>
        /// A collection of Lower and Upper Triangular Matrix Generated by LU factorization methods
        /// </summary>
        public Matrix<T> U_lu { get; protected set; } = null;

        /// <summary>
        /// A collection of Lower and Upper Triangular Matrix Generated by cholesky factorization methods
        /// </summary>
        public Matrix<T> L_chol { get; protected set; } = null;

        /// <summary>
        /// A collection of Lower and Upper Triangular Matrix Generated by cholesky factorization methods
        /// </summary>
        public Matrix<T> U_chol { get; protected set; } = null;

        /// <summary>
        /// An Orthonormal Matrix Generated by SVD decomposition methods
        /// </summary>
        public Matrix<T> U_svd { get; protected set; } = null;

        /// <summary>
        ///A Diagonal Matrix Generated by SVD decomposition methods
        /// </summary>
        public Matrix<T> S_svd { get; protected set; } = null;

        /// <summary>
        ///  An Orthonormal Matrix Generated by SVD decomposition methods
        /// </summary>
        public Matrix<T> V_svd { get; protected set; } = null;

        /// <summary>
        /// A Matrix Generated by BiDiagonal Reduction methods
        /// </summary>
        public Matrix<T> U_bdr { get; protected set; } = null;

        /// <summary>
        /// A Matrix Generated by BiDiagonal Reduction methods
        /// </summary>
        public Matrix<T> B_bdr { get; protected set; } = null;

        /// <summary>
        /// A Matrix Generated by BiDiagonal Reduction methods
        /// </summary>
        public Matrix<T> V_bdr { get; protected set; } = null;

        /// <summary>
        /// A Matrix Generated by TriDiagonal Reduction methods
        /// </summary>
        public Matrix<T> T_tdr { get; protected set; } = null;

        /// <summary>
        /// A Matrix Generated by TriDiagonal Reduction methods
        /// </summary>
        public Matrix<T> Q_tdr { get; protected set; } = null;

        /// <summary>
        /// Q Matrix Generated by QR factorization methods
        /// </summary>
        public Matrix<T> Q_qr { get; protected set; } = null;

        /// <summary>
        /// R Matrix Generated by QR factorization methods
        /// </summary>
        public Matrix<T> R_qr { get; protected set; } = null;

        /// <summary>
        /// Permutation Matrix Generated by LU factorization methods
        /// </summary>
        public Matrix<T> P;

        /// <summary>
        /// Matrix of EigenValues
        /// </summary>
        public Matrix<T> EigVals { get; protected set; } = null;

        /// <summary>
        /// Matrix of EigenVectors
        /// </summary>
        public Matrix<T> EigVecs { get; protected set; } = null;

        /// <summary>
        /// Array of Coefficient of Characteristics Polynomial
        /// </summary>
        public RowVec<T> Charpoly { get; protected set; } = null;

        public string Message { get; protected set; }

        /// <summary>
        /// Array of interger for permutation
        /// </summary>
        public int[] pi;

        int rows, cols;
        T[,] mat;
        bool isUpTri = false;
        bool isLowTri = false;
        bool isUpTriChecked = false;
        bool isLowTriChecked = false;
        bool isPosDef = false;
        bool luNotMade = true;
        bool charPolyNotMade = true;
        bool qrNotMade = true;
        bool cholNotMade = true;
        bool eigSysNotMade = true;
        bool triDiagNotmade = true;
        bool biDiagNotmade = true;
        bool svdNotmade = true;
        T detOfP;
        #endregion

        #region Constructor

        /// <summary>
        /// 
        /// </summary>
        /// <param name="entry"></param>
        public Matrix(T[,] entry)
        {
            rows = entry.GetLength(0);
            cols = entry.GetLength(1);
            mat = entry;
            detOfP = mat[0, 0].One();
        }

        public static implicit operator Matrix<T>(T[,]value)=>new Matrix<T>(value);
        

        /// <summary>
        /// 
        /// </summary>
        /// <param name="_rows"></param>
        /// <param name="_cols"></param>
        /// <param name="entry"></param>
        /// <param name="rows"></param>
        /// <param name="cols"></param>
        public Matrix(int[] _rows, int[] _cols, T[] entry, int rows, int cols)
        {
            this.rows = rows;
            this.cols = cols;
            mat = new T[rows, cols];
            detOfP = mat[0, 0].One();
            for (int i = 0; i < _rows.Length; i++)
            {
                var x = mat[_rows[i], _cols[i]];
                mat[_rows[i], _cols[i]] += x.Add(entry[i]);
            }
        }
        
        public Matrix( T[] entry)
        {
            rows = entry.Length;
            cols = 1;
            mat = new T[rows, cols];
            for (int i = 0; i < rows; i++) mat[i, 0] = entry[i];
            detOfP = mat[0, 0].One();
        }

        public static implicit operator Matrix<T>(T[] value) => new Matrix<T>(value);

        public static implicit operator Matrix<T>(T value) => new Matrix<T>(new T[,] { { value } });

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public IEnumerator<T> GetEnumerator()
        {
            for (int j = 0; j < cols; j++)
                for (int i = 0; i < rows; i++)
                    yield return mat[i, j];
        }

        IEnumerator IEnumerable.GetEnumerator()
        { yield return GetEnumerator(); }

        #endregion

        public dynamic Real()
        {
            if (mat[0, 0].GetType() == typeof(Int))
            {
                T[,] ans = new T[rows, cols];
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        ans[i, j] = mat[i, j].REAL();
                return (Matrix<T>)ans;
            }
            else
            {
                Doub[,] ans = new Doub[rows, cols];
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        ans[i, j] = mat[i, j].REAL();
                return (Matrix<Doub>)ans;
            }
        }

        public dynamic Imag()
        {
            if (mat[0, 0].GetType() == typeof(Int))
            {
                T[,] ans = new T[rows, cols];
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        ans[i, j] = mat[i, j].IMAG();
                return (Matrix<T>)ans;
            }
            else
            {
                Doub[,] ans = new Doub[rows, cols];
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        ans[i, j] = mat[i, j].IMAG();
                return (Matrix<Doub>)ans;
            }
        }

        public Matrix<T> Transpose()
        {
            T[,] trans = new T[cols, rows];
            for (int i = 0; i < rows; i++)
                for (int j = 0; j < cols; j++)
                    trans[j, i] = mat[i, j].Conj();
            return trans;
        }

        public Matrix<T> DotTranspose()
        {
            T[,] trans = new T[cols, rows];
            for (int i = 0; i < rows; i++)
                for (int j = 0; j < cols; j++)
                    trans[j, i] = mat[i, j];
            return trans;
        }

        /// </summary>
        /// <param name="N">Number of rows</param>
        /// <param name="M">Number of columns</param>
        /// <returns>Matrix</returns>
        public static Matrix<T> Zeros(int N, int M)
        {
            return new T[N, M];
        }

        /// <summary>
        ///  Square matrix of size N by N contaning 0's
        /// </summary>
        /// <param name="N">Number of rows and colmuns</param>
        /// <returns>Matrix</returns>
        public static Matrix<T> Zeros(int N)
        {
            return new T[N, N];
        }

        /// <summary>
        ///  Matrix of size N[0] by N[1] contaning 0's
        /// </summary>
        /// <param name="N">Number of rows and columns</param>
        /// <returns>Matrix</returns>
        public static Matrix<T> Zeros(int[] N)
        {
            return new T[N[0], N[1]];
        }

        /// <summary>
        ///  Matrix of size N[0] by N[1] contaning 0's
        /// </summary>
        /// <param name="N">Number of rows and columns</param>
        /// <returns>Matrix</returns>
        public static Matrix<T> Ones(int[] N)
        {
            T[,] ans = new T[N[0], N[1]];
            for (int i = 0; i < N[0]; i++)
            {
                for (int j = 0; j < N[1]; j++)
                {
                    ans[i, j] = ans[i, j].One();
                }
            }
            return ans;
        }

        public static Matrix<T> Ones(int N, int M)
        {
            T[,] ans = new T[N, M];
            for (int i = 0; i < N; i++)
            {
                for (int j = 0; j < M; j++)
                {
                    ans[i, j] = ans[i, j].One();
                }
            }
            return ans;
        }

        /// <summary>
        ///  Square matrix of size N by N contaning 0's
        /// </summary>
        /// <param name="N">Number of rows and colmuns</param>
        /// <returns>Matrix</returns>
        public static Matrix<T> Ones(int N)
        {
            T[,] ans = new T[N, N];
            for (int i = 0; i < N; i++)
            {
                for (int j = 0; j < N; j++)
                {
                    ans[i, j] = ans[i, j].One();
                }
            }
            return ans;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="N"></param>
        /// <param name="M"></param>
        /// <returns></returns>
        public static Matrix<T> Eye(int N, int M)
        {
            T[,] ans = new T[N, M]; T One = ans[0, 0].One();
            for (int i = 0; i < Math.Min(N,M); i++) ans[i, i] = One;
            return ans;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="N"></param>
        /// <returns></returns>
        public static Matrix<T> Eye(int N)
        {
            T[,] ans = new T[N, N]; T One = ans[0, 0].One();
            for (int i = 0; i < N; i++) ans[i, i] = One;
            return ans;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="N"></param>
        /// <returns></returns>
        public static Matrix<T> Eye(int[] N)
        {
            T[,] ans = new T[N[0], N[1]]; T One = ans[0, 0].One();
            for (int i = 0; i < N.Min(); i++) ans[i, i] = One;
            return ans;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public Matrix<T> Duplicate()
        {
            T[,] ans = new T[rows, cols];
            for (int i = 0; i < rows; i++)
            {
                for (int j = 0; j < cols; j++)
                {
                    ans[i, j] = mat[i, j];
                }
            }
            return ans;
        }

        public Matrix<T> Conj()
        {
            T[,] ans = new T[rows, cols];
            for (int i = 0; i < rows; i++)
            {
                for (int j = 0; j < cols; j++)
                {
                    ans[i, j] = mat[i, j].Conj();
                }
            }
            return ans;
        }

        public bool IsSquare() => rows == cols;

        public bool IsSymmetric()
        {
            bool ans = true;
            for (int i = 0; i < rows; i++)
                for (int j = 0; j < i; j++)
                    ans = ans && (mat[i, j].Sub(mat[j, i])).Abs() < 1e-14;
            return ans;
        }

        public bool IsTriDiag()
        {
            bool ans = IsSquare();
            for (int i = 0; i < rows - 2; i++)
                for (int j = i + 2; j < cols; j++)
                {
                    ans = ans && (mat[i, j].Abs() < 1e-16)
                              && (mat[j, i].Abs() < 1e-16);
                    if (!ans) break;
                }
            return ans;
        }

        /// <summary>
        /// Test to determine if the Matrix is upper triangular
        /// </summary>
        /// <returns>bool</returns>
        public bool IsUpTri()
        {
            if (isUpTriChecked) return isUpTri;
            else
            {
                isUpTriChecked = true;
                isUpTri = IsSquare() && (mat[0, 0].Abs() > 1e-16);
                for (int i = 1; i < rows; i++)
                    for (int j = 0; j < i; j++)
                    {
                        isUpTri = isUpTri && (mat[i, j].Abs() < 1e-16);
                        if (!isUpTri) break;
                    }
                return isUpTri;
            }
        }

        /// <summary>
        /// Test to determine if the Matrix is upper triangular
        /// </summary>
        /// <returns>bool</returns>
        public bool IsLowTri()
        {
            if (isLowTriChecked) return isLowTri;
            else
            {
                isUpTriChecked = true;
                isLowTriChecked = true;
                isLowTri = IsSquare() && (mat[0, 0].Abs() > 1e-16);
                for (int i = 0; i < rows - 1; i++)
                    for (int j = i + 1; j < rows; j++)
                    {
                        isLowTri = isLowTri && (mat[j, i].Abs() < 1e-16);
                        if (!isLowTri) break;
                    }
                return isLowTri;
            }
        }

        public bool IsDiag()
        {
            if (isUpTriChecked ^ isLowTriChecked)
            {
                if (!isUpTriChecked) IsUpTri();
                if (!isLowTriChecked) IsLowTri();

            }
            else
            {
                isUpTri = IsSquare(); isLowTri = IsSquare();
                for (int i = 0; i < rows - 1; i++)
                    for (int j = i + 1; j < cols; j++)
                    {
                        isUpTri = isUpTri && (mat[i, j].Abs() < 1e-16);
                        isLowTri = isLowTri && (mat[j, i].Abs() < 1e-16);
                        if (!isLowTri ) break;
                        if (!isUpTri) break;
                    }
            }
            return isUpTri && isLowTri;
        }

        public static Matrix<T> Solve(Matrix<T> A, Matrix<T> b)
        {
            if (A.isPosDef)
            { return BackSubs(A.U_chol, ForwardSubs(A.L_chol, b)); }
            else
            {
                if (A.rows < A.cols)
                { return mult(A.Transpose(), Solve(mult(A, A.Transpose()), b)); }
                else if (A.rows > A.cols)
                {   Matrix<T> A2 = mult(A.Transpose(), A), b2 = mult(A.Transpose(), b);
                    return Solve(A2, b2); }
                else
                {
                    if (A.IsDiag())
                    { return b.Div(Diag(A)); }
                    else if (A.isUpTri)
                    { return BackSubs(A, b); }
                    else if (A.isLowTri)
                    { return ForwardSubs(A, b); }
                    else if (A.IsTriDiag())
                    { return TriSolve(A, b); }
                    else
                    {   if (A.luNotMade) A.MakeLU();
                        T[,] bpi = new T[b.rows, b.cols];
                        for (int i = 0; i < b.rows; i++)
                            for (int j = 0; j < b.cols; j++) bpi[i, j] = b.mat[A.pi[i], j];
                        return BackSubs(A.U_lu, ForwardSubs(A.L_lu, bpi)); }
                }
            }
        }

        public void MakeLU()
        {
            luNotMade = false;
            if (!IsSquare()) throw new Exception("The matrix is not square!");
            L_lu = Eye(rows);
            U_lu = Duplicate();
            pi = new int[rows]; int pom1, I = rows, J = cols, k;
            T pom2, f; double m; detOfP = mat[0,0].One();
            for (int i = 0; i < I; i++) pi[i] = i;

            for (int i = 0; i < I - 1; i++)
            {
                m = U_lu.mat[i, i].Abs(); k = i;
                for (int j = i+1; j < rows; j++)
                {
                    if(m < U_lu.mat[j, i].Abs())
                    {
                        m = U_lu.mat[j, i].Abs();
                        k = j;
                    }
                }
                if (m == 0)
                {
                    U_lu.mat[i, i] = detOfP.TINYNO();
                    Message = "Matrix is singular to machine precision";
                }
                if (k != i)
                {
                    U_lu.SwapRows(k, i); // swap if the maximum is not in the present row
                    detOfP.Mult(-1);
                    pom1 = pi[k]; pi[k] = pi[i]; pi[i] = pom1;    // switch two rows in permutation matrix
                    for (int j = 0; j < i; j++)
                    {
                        pom2 = L_lu.mat[i, j]; L_lu.mat[i, j] = L_lu.mat[k, j]; L_lu.mat[k, j] = pom2;
                    }
                }
                for (k = i + 1; k < I; k++)
                {
                    f = U_lu.mat[k, i].Div(U_lu.mat[i, i]);
                    U_lu.mat[k, i] = U_lu.mat[k, i].Zero(); L_lu.mat[k, i] = f;
                    for (int t = i + 1; t < J; t++)
                    {
                        U_lu.mat[k, t] = U_lu.mat[k, t].Sub(U_lu.mat[i, t].Mult(f));
                    }
                }
            }
        }

        public void Choldc()
        {
            cholNotMade = false;
            L_chol = new T[rows, rows];
            Matrix<T> copy = Duplicate();
            int i, j, k;
            T sum;
            P = new T[rows, 1];
            for (i = 0; i < rows; i++)
            {
                for (j = i; j < rows; j++)
                {
                    for (sum = copy.mat[i, j], k = i - 1; k >= 0; k--) 
                        sum = sum.Sub(copy.mat[i, k].Mult(copy.mat[j, k]));
                    if (i == j)
                    {
                        if (sum.CompareTo(sum.Zero()) < 0)
                        {
                            L_chol = U_chol = null;
                            isPosDef = false;
                            return;
                        }
                        P.mat[i,0] = sum.Sqrt(sum);
                    }
                    else
                    {
                        copy.mat[j, i] = sum.Div(P.mat[i,0]);
                        L_chol.mat[j, i] = copy.mat[j, i];
                    }
                }
            }
            for (i = 0; i < rows; i++) L_chol.mat[i, i] = P.mat[i, 0];
            U_chol = L_chol.DotTranspose();
            isPosDef = true;
        }

        // Determinant
        public T Det()
        {
            if (IsSymmetric())
            {
                try
                {
                    if (cholNotMade) Choldc();
                    for (int i = 0; i < rows; i++)
                        detOfP = detOfP.Mult(P.mat[i,0]);
                    detOfP = detOfP.Mult(detOfP);
                }
                catch
                {
                    if (luNotMade) MakeLU();
                    for (int i = 0; i < rows; i++)
                        detOfP = detOfP.Mult(U_lu.mat[i, i]);
                }
            }
            else
            {
                if (luNotMade) MakeLU();
                for (int i = 0; i < rows; i++)
                    detOfP = detOfP.Mult(U_lu.mat[i, i]);
            }
            return detOfP;
        }

        public T Trace()
        {
            if (!IsSquare())
                throw new Exception("");
            T trace = mat[0, 0];
            for (int i = 0; i < rows; i++) trace = trace.Add(mat[i, i]);
            return trace;
        }

        static Matrix<T> mult(Matrix<T> A, Matrix<T> B)
        {
            if (A.cols != B.rows)
                throw new Exception("Matrices are not conformable for multiplication");
            T[,] C = new T[A.rows, B.cols];
            for (int i = 0; i < A.rows; i++)
            {
                for (int j = 0; j < B.cols; j++)
                {
                    for (int k = 0; k < A.cols; k++)
                    {
                        C[i, j] = C[i, j].Add(A.mat[i, k].Mult(B.mat[k, j]));
                    }
                }
            }
            return C;
        }

        public Matrix<T> Mult(Matrix<T> B)
        {
            T[,] C;
            if (B.Numel == 1)
            {
                C = new T[rows, cols];
                for (int i = 0; i < rows; i++)
                {
                    for (int j = 0; j < cols; j++)
                    {
                        C[i, j] = mat[i, j].Mult(B.mat[0, 0]);
                    }
                }
            }
            else if (Numel == 1)
            {
                C = new T[B.rows, B.cols];
                for (int i = 0; i < B.rows; i++)
                {
                    for (int j = 0; j < B.cols; j++)
                    {
                        C[i, j] = mat[0, 0].Mult(B.mat[i, j]);
                    }
                }
            }
            else
            {
                if (cols != B.cols || rows != B.rows)
                    throw new Exception("Matrices are not conformable for multiplication");
                C = new T[rows, cols];
                for (int i = 0; i < rows; i++)
                {
                    for (int j = 0; j < cols; j++)
                    {
                        C[i, j] = mat[i, j].Mult(B.mat[i, j]);
                    }
                }
            }
            return C;
        }

        public Matrix<T> Div(Matrix<T> B)
        {
            T[,] C;
            if (B.Numel == 1)
            {
                C = new T[rows, cols];
                for (int i = 0; i < rows; i++)
                {
                    for (int j = 0; j < cols; j++)
                    {
                        C[i, j] = mat[i, j].Div(B.mat[0, 0]);
                    }
                }
            }
            else if (Numel == 1)
            {
                C = new T[B.rows, B.cols];
                for (int i = 0; i < B.rows; i++)
                {
                    for (int j = 0; j < B.cols; j++)
                    {
                        C[i, j] = mat[0, 0].Div(B.mat[i, j]);
                    }
                }
            }
            else
            {
                if (cols != B.cols || rows != B.rows)
                    throw new Exception("Matrices are not conformable for multiplication");
                C = new T[rows, cols];
                for (int i = 0; i < rows; i++)
                {
                    for (int j = 0; j < cols; j++)
                    {
                        C[i, j] = mat[i, j].Div(B.mat[i, j]);
                    }
                }
            }
            return C;
        }

        public Matrix<T> Pow(Matrix<T> B)
        {
            T[,] C;
            if (B.Numel == 1)
            {
                C = new T[rows, cols];
                for (int i = 0; i < rows; i++)
                {
                    for (int j = 0; j < cols; j++)
                    {
                        C[i, j] = mat[i, j].Pow(B.mat[0, 0]);
                    }
                }
            }
            else if (Numel == 1)
            {
                C = new T[B.rows, B.cols];
                for (int i = 0; i < B.rows; i++)
                {
                    for (int j = 0; j < B.cols; j++)
                    {
                        C[i, j] = mat[0, 0].Pow(B.mat[i, j]);
                    }
                }
            }
            else
            {
                if (cols != B.cols || rows != B.rows)
                    throw new Exception("Matrices are not conformable for multiplication");
                C = new T[rows, cols];
                for (int i = 0; i < rows; i++)
                {
                    for (int j = 0; j < cols; j++)
                    {
                        C[i, j] = mat[i, j].Pow(B.mat[i, j]);
                    }
                }
            }
            return C;
        }

        static Matrix<T> Add(Matrix<T> A, Matrix<T> B)
        {
            T[,] C;
            if (B.Numel == 1)
            {
                C = new T[A.rows, A.cols];
                for (int i = 0; i < A.rows; i++)
                {
                    for (int j = 0; j < A.cols; j++)
                    {
                        C[i, j] = A.mat[i, j].Add(B.mat[0, 0]);
                    }
                }
            }
            else if (A.Numel == 1)
            {
                C = new T[B.rows, B.cols];
                for (int i = 0; i < B.rows; i++)
                {
                    for (int j = 0; j < B.cols; j++)
                    {
                        C[i, j] = A.mat[0, 0].Add(B.mat[i, j]);
                    }
                }
            }
            else
            {
                if (A.cols != B.cols || A.rows != B.rows)
                    throw new Exception("Matrices are not conformable for multiplication");
                C = new T[A.rows, A.cols];
                for (int i = 0; i < A.rows; i++)
                {
                    for (int j = 0; j < A.cols; j++)
                    {
                        C[i, j] = A.mat[i, j].Add(B.mat[i, j]);
                    }
                }
            }
            return C;
        }

        static Matrix<T> Sub(Matrix<T> A, Matrix<T> B)
        {
            T[,] C;
            if (B.Numel == 1)
            {
                C = new T[A.rows, A.cols];
                for (int i = 0; i < A.rows; i++)
                {
                    for (int j = 0; j < A.cols; j++)
                    {
                        C[i, j] = A.mat[i, j].Sub(B.mat[0, 0]);
                    }
                }
            }
            else if (A.Numel == 1)
            {
                C = new T[B.rows, B.cols];
                for (int i = 0; i < B.rows; i++)
                {
                    for (int j = 0; j < B.cols; j++)
                    {
                        C[i, j] = A.mat[0, 0].Sub(B.mat[i, j]);
                    }
                }
            }
            else
            {
                if (A.cols != B.cols || A.rows != B.rows)
                    throw new Exception("Matrices are not conformable for multiplication");
                C = new T[A.rows, A.cols];
                for (int i = 0; i < A.rows; i++)
                {
                    for (int j = 0; j < A.cols; j++)
                    {
                        C[i, j] = A.mat[i, j].Sub(B.mat[i, j]);
                    }
                }
            }
            return C;
        }

        public static Matrix<T> Diag(Matrix<T> A, int k = 0)
        {
            if (A.cols == 1)
            {
                T[,] ans = new T[A.rows + Math.Abs(k), A.rows + Math.Abs(k)];
                if (k > 0)
                {
                    for (int i = 0; i < A.rows; i++)
                    {
                        ans[i, i + Math.Abs(k)] = A.mat[i, 0];
                    }
                    return ans;
                }
                else
                {
                    for (int i = 0; i < A.rows; i++)
                    {
                        ans[i + Math.Abs(k), i] = A.mat[i, 0];
                    }
                    return ans;
                }
            }
            else
            {
                if (k > 0)
                {
                    int N = A.cols - Math.Abs(k);
                    T[,] ans = new T[N, 1];
                    for (int i = 0; i < N; i++)
                    {
                        ans[i, 0] = A.mat[i, i + Math.Abs(k)];
                    }
                    return ans;
                }
                else
                {
                    int N = A.rows - Math.Abs(k);
                    T[,] ans = new T[N, 1];
                    for (int i = 0; i < N; i++)
                    {
                        ans[i, 0] = A.mat[i + Math.Abs(k), i];
                    }
                    return ans;
                }
            }
        }

        public override string ToString()
        {
            int L = (mat[0, 0].GetType() == typeof(Int)) ? 9 : 3;
            double max = mat[0, 0].Abs();
            for (int i = 0; i < rows; i++)
            {
                for (int j = 0; j < cols; j++)
                {
                    max = Math.Max(max, mat[i, j].Abs());
                }
            }
            int Nh = (max == 0 || double.IsNaN(max))? 0 : (int)Math.Log10(max);
            string ans = ""; double scale = 1;
            if (Math.Abs(Nh) >= L)
            {
                ans = "1.0e+";
                if (Nh < 0) Nh--;
                ans += (Math.Abs(Nh) < 10) ? "0" + Nh : Nh.ToString();
                ans += " * \n";
                scale = Math.Pow(10, -Nh);
            }
            ans += ToStringScaled(scale);
            return ans;
        }

        string ToStringScaled(Doub scale)
        {
            string ans = "";
            if (scale == 1)
            {
                for (int j = 0; j < cols - 1; j++)
                    ans += mat[0, j].ToString4Array() + "\t";
                ans += mat[0, cols - 1].ToString4Array() + "\n";
                for (int i = 1; i < rows; i++)
                {
                    for (int j = 0; j < cols - 1; j++)
                        ans += mat[i, j].ToString4Array() + "\t";
                    ans += mat[i, cols - 1].ToString4Array() + "\n";
                }
                return ans;
            }
            else
            {
                dynamic[,] temp = new dynamic[rows, cols];
                for (int i = 0; i < rows; i++)
                    for (int j = 0; j < cols; j++)
                        temp[i, j] = mat[i, j].Mult(scale);

                for (int j = 0; j < cols - 1; j++)
                    ans += temp[0, j].ToString4Array() + "\t";
                ans += temp[0, cols - 1].ToString4Array() + "\n";
                for (int i = 1; i < rows; i++)
                {
                    for (int j = 0; j < cols - 1; j++)
                        ans += temp[i, j].ToString4Array() + "\t";
                    ans += temp[i, cols - 1].ToString4Array() + "\n";
                }
                return ans;
            }
        }

        /// Swap a two specified columns.
        /// </summary>
        /// <param name="M">Column 1</param>
        /// <param name="N">Column 2</param>
        /// <returns>Void</returns>
        public void SwapColumns(int M, int N)
        {
            if (Math.Max(M, N) > cols)
                throw new Exception("Out of Bound Index");
            T temp;
            for (int i = 0; i < rows; i++)
            {
                temp = mat[i, M];
                mat[i, M] = mat[i, N];
                mat[i, N] = temp;
            }
        }

        /// Swap a two specified columns.
        /// </summary>
        /// <param name="M">Column 1</param>
        /// <param name="N">Column 2</param>
        /// <returns>Void</returns>
        public void SwapRows(int M, int N)
        {
            if (Math.Max(M, N) > rows)
                throw new Exception("Out of Bound Index");
            T temp;
            for (int i = 0; i < rows; i++)
            {
                temp = mat[M, i];
                mat[M, i] = mat[N, i];
                mat[N, i] = temp;
            }
        }

        public static Matrix<T> TriSolve(Matrix<T> A, Matrix<T> d)
        {
            int I = d.rows, J = d.cols; T temp;
            T[] a = new T[I], b = new T[I], c = new T[I];
            for (int i = 0; i < I; i++)
            {
                if (i > 0) a[i] = A.mat[i, i - 1];
                b[i] = A.mat[i, i];
                if (i < I - 1) c[i] = A.mat[i, i + 1];
            }
            T[,] x = new T[I, J];
            c[0] = c[0].Div(b[0]);
            for (int j = 0; j < J; j++) d.mat[0, j] = d.mat[0, j].Div(b[0]);
            for (int i = 1; i < I; i++)
            {
                temp = b[i].Sub(a[i].Mult(c[i - 1]));
                c[i] = c[i].Div(temp);
                for (int j = 0; j < J; j++)
                    d.mat[i,j] = (d.mat[i,j].Sub(a[i].Mult(d.mat[i - 1,j]))).Div(temp);
            }
            for (int j = 0; j < J; j++) x[I - 1, j] = d.mat[I - 1, j];
            for (int i = I - 2; i >= 0; i--)
            {
                for (int j = 0; j < J; j++) x[i, j] = d.mat[i,j].Sub(c[i].Mult(x[i + 1,j]));
            }
            return x;
        }

        // Forward Substitution
        public static Matrix<T> ForwardSubs(Matrix<T> U, Matrix<T> b)
        {
            int I = U.rows;
            T[,] ans = new T[b.rows, b.cols];
            for (int j = 0; j < b.cols; j++) ans[0, j] = b.mat[0, j].Div(U.mat[0, 0]);
            for (int i = 1; i < I; i++)
            {
                for (int j = 0; j < b.cols; j++) ans[i, j] = b.mat[i, j];
                for (int k = 0; k < i; k++)
                {
                    for (int j = 0; j < b.cols; j++) ans[i, j] = ans[i, j].Sub(U.mat[i, k].Mult(ans[k, j]));
                }
                for (int j = 0; j < b.cols; j++) ans[i, j] = ans[i, j].Div(U.mat[i, i]);
            }
            return ans;
        }

        // Backward Substitution
        public static Matrix<T> BackSubs(Matrix<T> U, Matrix<T> b)
        {
            int I = U.rows;
            T[,] ans = new T[b.rows, b.cols];
            for (int i = I - 1; i > -1; i--)
            {
                for (int j = 0; j < b.cols; j++) ans[i, j] = b.mat[i, j];
                for (int k = I - 1; k > i; k--)
                {
                    for (int j = 0; j < b.cols; j++) ans[i, j] = ans[i, j].Sub(U.mat[i, k].Mult(ans[k, j]));
                }
                for (int j = 0; j < b.cols; j++) ans[i, j] = ans[i, j].Div(U.mat[i, i]);
            }
            return ans;
        }

        public static Matrix<T> Hilb(int N, int M)
        {
            T[,] ans = new T[N, M]; T temp = ans[0, 0].One();
            for (int i = 0; i < N; i++)
                for (int j = 0; j < M; j++)
                    ans[i, j] = temp.Div(i + j + 1);
            return ans;
        }

        public static Matrix<T> Rand(int N, int M)
        {
            T[,] ans = new T[N, M]; 
            for (int i = 0; i < N; i++)
                for (int j = 0; j < M; j++)
                    ans[i, j] = ans[0,0].Rand();
            return ans;
        }

        public static Matrix<T> Rand(int N)
        {
            T[,] ans = new T[N, N];
            for (int i = 0; i < N; i++)
                for (int j = 0; j < N; j++)
                    ans[i, j] = ans[i, j].Rand();
            return ans;
        }

        public static Matrix<T> Round(Matrix<T>M, int N)
        {
            T[,] ans = new T[M.rows, M.cols];
            for (int i = 0; i < M.rows; i++)
                for (int j = 0; j < M.cols; j++)
                    ans[i, j] = M.mat[i, j].Round(N);
            return ans;
        }

        public static Matrix<T> Sign(Matrix<T> M)
        {
            T[,] ans = new T[M.rows, M.cols];
            for (int i = 0; i < M.rows; i++)
                for (int j = 0; j < M.cols; j++)
                    ans[i, j] = M.mat[i, j].Sign();
            return ans;
        }

        public static Matrix<T> Sin(Matrix<T> M)
        {
            T[,] ans = new T[M.rows, M.cols];
            for (int i = 0; i < M.rows; i++)
                for (int j = 0; j < M.cols; j++)
                    ans[i, j] = M.mat[i, j].Sin();
            return ans;
        }

        public static Matrix<T> Cos(Matrix<T> M)
        {
            T[,] ans = new T[M.rows, M.cols];
            for (int i = 0; i < M.rows; i++)
                for (int j = 0; j < M.cols; j++)
                    ans[i, j] = M.mat[i, j].Cos();
            return ans;
        }

        public static Matrix<T> Tan(Matrix<T> M)
        {
            T[,] ans = new T[M.rows, M.cols];
            for (int i = 0; i < M.rows; i++)
                for (int j = 0; j < M.cols; j++)
                    ans[i, j] = M.mat[i, j].Tan();
            return ans;
        }

        public static Matrix<T> Sinh(Matrix<T> M)
        {
            T[,] ans = new T[M.rows, M.cols];
            for (int i = 0; i < M.rows; i++)
                for (int j = 0; j < M.cols; j++)
                    ans[i, j] = M.mat[i, j].Sin();
            return ans;
        }

        public static Matrix<T> Cosh(Matrix<T> M)
        {
            T[,] ans = new T[M.rows, M.cols];
            for (int i = 0; i < M.rows; i++)
                for (int j = 0; j < M.cols; j++)
                    ans[i, j] = M.mat[i, j].Cos();
            return ans;
        }

        public static Matrix<T> Tanh(Matrix<T> M)
        {
            T[,] ans = new T[M.rows, M.cols];
            for (int i = 0; i < M.rows; i++)
                for (int j = 0; j < M.cols; j++)
                    ans[i, j] = M.mat[i, j].Tan();
            return ans;
        }

        public static dynamic Asin(Matrix<T> M)
        {
            Complex[,] a = new Complex[M.rows, M.cols];
            bool IsComplex = false;
            for (int i = 0; i < M.rows; i++)
                for (int j = 0; j < M.cols; j++)
                {
                    a[i, j] = M.mat[i, j].Asin();
                    IsComplex = IsComplex || a[i, j].IsComplex();
                }
            if (IsComplex)
            {
                Complex[,] ans = new Complex[M.rows, M.cols];
                for (int i = 0; i < M.rows; i++)
                    for (int j = 0; j < M.cols; j++)
                        ans[i, j] = a[i, j];
                return (Matrix<Complex>)ans;
            }
            else
            {
                Doub[,] ans = new Doub[M.rows, M.cols];
                for (int i = 0; i < M.rows; i++)
                    for (int j = 0; j < M.cols; j++)
                        ans[i, j] = a[i, j].Real;
                return (Matrix<Doub>)ans;
            }
        }

        public static dynamic Acos(Matrix<T> M)
        {
            dynamic[,] a = new dynamic[M.rows, M.cols];
            bool IsComplex = false;
            for (int i = 0; i < M.rows; i++)
                for (int j = 0; j < M.cols; j++)
                {
                    a[i, j] = M.mat[i, j].Acos();
                    IsComplex = IsComplex || a[i, j].IsComplex();
                }
            if (IsComplex)
            {
                Complex[,] ans = new Complex[M.rows, M.cols];
                for (int i = 0; i < M.rows; i++)
                    for (int j = 0; j < M.cols; j++)
                        ans[i, j] = a[i, j];
                return (Matrix<Complex>)ans;
            }
            else
            {
                Doub[,] ans = new Doub[M.rows, M.cols];
                for (int i = 0; i < M.rows; i++)
                    for (int j = 0; j < M.cols; j++)
                        ans[i, j] = a[i, j].Real;
                return (Matrix<Doub>)ans;
            }
        }

        public static Matrix<T> Atan(Matrix<T> M)
        {
            T[,] ans = new T[M.rows, M.cols];
            for (int i = 0; i < M.rows; i++)
                for (int j = 0; j < M.cols; j++)
                    ans[i, j] = M.mat[i, j].Atan();
            return ans;
        }

        public static Matrix<T> Asinh(Matrix<T> M)
        {
            T[,] ans = new T[M.rows, M.cols];
            for (int i = 0; i < M.rows; i++)
                for (int j = 0; j < M.cols; j++)
                    ans[i, j] = M.mat[i, j].Asinh();
            return ans;
        }

        public static dynamic Acosh(Matrix<T> M)
        {
            dynamic[,] a = new dynamic[M.rows, M.cols];
            bool IsComplex = false;
            for (int i = 0; i < M.rows; i++)
                for (int j = 0; j < M.cols; j++)
                {
                    a[i, j] = M.mat[i, j].Acosh();
                    IsComplex = IsComplex || a[i, j].IsComplex();
                }
            if (IsComplex)
            {
                Complex[,] ans = new Complex[M.rows, M.cols];
                for (int i = 0; i < M.rows; i++)
                    for (int j = 0; j < M.cols; j++)
                        ans[i, j] = a[i, j];
                return (Matrix<Complex>)ans;
            }
            else
            {
                Doub[,] ans = new Doub[M.rows, M.cols];
                for (int i = 0; i < M.rows; i++)
                    for (int j = 0; j < M.cols; j++)
                        ans[i, j] = a[i, j].Real;
                return (Matrix<Doub>)ans;
            }
        }

        public static dynamic Atanh(Matrix<T> M)
        {
            dynamic[,] a = new dynamic[M.rows, M.cols];
            bool IsComplex = false;
            for (int i = 0; i < M.rows; i++)
                for (int j = 0; j < M.cols; j++)
                {
                    a[i, j] = M.mat[i, j].Atanh();
                    IsComplex = IsComplex || a[i, j].IsComplex();
                }
            if (IsComplex)
            {
                Complex[,] ans = new Complex[M.rows, M.cols];
                for (int i = 0; i < M.rows; i++)
                    for (int j = 0; j < M.cols; j++)
                        ans[i, j] = a[i, j];
                return (Matrix<Complex>)ans;
            }
            else
            {
                Doub[,] ans = new Doub[M.rows, M.cols];
                for (int i = 0; i < M.rows; i++)
                    for (int j = 0; j < M.cols; j++)
                        ans[i, j] = a[i, j].Real;
                return (Matrix<Doub>)ans;
            }
        }

        /// <summary>
        /// Access this matrix as a 1D array
        /// </summary>
        /// <param name="I"></param>
        /// <returns></returns>
        public T this[int I]
        {
            get { return mat[I % rows, I / rows]; }
            set { mat[I % rows, I / rows] = value; }
        }

        /// <summary>
        /// Access this matrix as a 1D array
        /// </summary>
        /// <param name="I"></param>
        /// <returns></returns>
        public Matrix<T> this[int[] I]
        {
            get { return GetSubMat(I); }
            set { SetSubMat(I, value); }
        }

        /// <summary>
        /// Access this matrix as a 1D array
        /// </summary>
        /// <param name="I"></param>
        /// <returns></returns>
        public Matrix<T> this[Matrix<Int> I]
        {
            get { return GetSubMat(I); }
            set { SetSubMat(I, value); }
        }

        private void SetSubMat(int[] I, Matrix<T> value)
        {
            if (I.Length != value.Numel) throw new Exception("Size Mismatched");
            for (int i = 0; i < I.Length; i++)
            {
                mat[I[i] % rows, I[i] / rows] = value[i];
            }
        }

        private Matrix<T> GetSubMat(int[] I)
        {
            T[,] ans = new T[I.Length, 1];
            for (int i = 0; i < I.Length; i++)
            {
                ans[i,0] = mat[I[i] % rows, I[i] / rows];
            }
            return ans;
        }

        private void SetSubMat(Matrix<Int> I, Matrix<T> value)
        {
            if (I.rows != value.rows || I.cols != value.cols) throw new Exception("Size Mismatched");
            for (int i = 0; i < I.Numel; i++)
            {
                mat[(int)I[i] % rows, (int)I[i] / rows] = value[i];
            }
        }

        private Matrix<T> GetSubMat(Matrix<Int> I)
        {
            T[,] ans = new T[I.rows, I.cols];
            for (int i = 0; i < I.rows; i++)
            {
                for (int j = 0; j < I.cols; j++)
                {
                    ans[i, j] = mat[(int)I[i,j] % rows, (int)I[i,j] / rows];
                }
            }
            return ans;
        }

        /// <summary>
        /// Access this matrix as a 2D array
        /// </summary>
        /// <param name="I"></param>
        /// <returns></returns>
        public T this[int I, int J]
        {
            get { return mat[I, J]; }
            set { mat[I, J] = value; }
        }

        /// <summary>
        /// Access this matrix as a 2D array
        /// </summary>
        /// <param name="I"></param>
        /// <returns></returns>
        public Matrix<T> this[int[] I, int J]
        {
            get{ return GetSubMat(I, new int[] { J }); }
            set{ SetSubMat(I, new int[] { J }, value); }
        }

        public Matrix<T> this[Matrix<Int> I, Matrix<Int> J]
        {
            get { return GetSubMat(I, J ); }
            set { SetSubMat(I, J , value); }
        }

        /// <summary>
        /// Access this matrix as a 2D array
        /// </summary>
        /// <param name="I"></param>
        /// <returns></returns>
        public Matrix<T> this[int I, int[] J]
        {
            get { return GetSubMat(new int[] { I }, J); }
            set { SetSubMat(new int[] { I }, J, value); }
        }

        /// <summary>
        /// Access this matrix as a 2D array
        /// </summary>
        /// <param name="I"></param>
        /// <returns></returns>
        public Matrix<T> this[int[] I, string J]
        {
            get { return GetSubMat(I, Stp(0,cols-1)); }
            set { SetSubMat(I, Stp(0, cols-1), value); }
        }

        /// <summary>
        /// Access this matrix as a 2D array
        /// </summary>
        /// <param name="I"></param>
        /// <returns></returns>
        public Matrix<T> this[string I, int[] J]
        {
            get { return GetSubMat(Stp(0, rows-1), J); }
            set { SetSubMat(Stp(0, rows-1), J, value); }
        }

        /// <summary>
        /// Access this matrix as a 2D array
        /// </summary>
        /// <param name="I"></param>
        /// <returns></returns>
        public Matrix<T> this[int I, string J]
        {
            get { return GetSubMat(new int[] { I }, Stp(0, cols-1)); }
            set { SetSubMat(new int[] { I }, Stp(0, cols-1), value); }
        }

        /// <summary>
        /// Access this matrix as a 2D array
        /// </summary>
        /// <param name="I"></param>
        /// <returns></returns>
        public Matrix<T> this[string I, int J]
        {
            get { return GetSubMat(Stp(0, rows-1), new int[] { J }); }
            set { SetSubMat(Stp(0, rows-1), new int[] { J }, value); }
        }

        /// <summary>
        /// Access this matrix as a 2D array
        /// </summary>
        /// <param name="I"></param>
        /// <returns></returns>
        public Matrix<T> this[int[] I, int[] J]
        {
            get { return GetSubMat(I, J); }
            set { SetSubMat(I, J, value); }
        }

        Matrix<T> GetSubMat(int[]I, int[]J)
        {
            T[,] ans = new T[I.Length, J.Length];
            for (int i = 0; i < I.Length; i++)
                for (int j = 0; j < J.Length; j++)
                    ans[i, j] = mat[I[i], J[j]];
            return ans;
        }

        Matrix<T> GetSubMat(Matrix<Int> II, Matrix<Int> JJ)
        {
            int[] I = II.Select(i => { return (int)i; }).ToArray();
            int[] J = JJ.Select(i => { return (int)i; }).ToArray();
            T[,] ans = new T[I.Length, J.Length];
            for (int i = 0; i < I.Length; i++)
                for (int j = 0; j < J.Length; j++)
                    ans[i, j] = mat[I[i], J[j]];
            return ans;
        }

        void SetSubMat(int[] I, int[] J, Matrix<T> V)
        {
            for (int i = 0; i < I.Length; i++)
                for (int j = 0; j < J.Length; j++)
                    mat[I[i], J[j]] = V.mat[i, j];
        }

        void SetSubMat(Matrix<Int> II, Matrix<Int> JJ, Matrix<T> V)
        {
            int[] I = II.Select(i => { return (int)i; }).ToArray();
            int[] J = JJ.Select(i => { return (int)i; }).ToArray();
            for (int i = 0; i < I.Length; i++)
                for (int j = 0; j < J.Length; j++)
                    mat[I[i], J[j]] = V.mat[i, j];
        }

        int[] Stp(int start, int end)
        {
            int step = 1; int N = (end - start) / step + 1;
            int[] ans = new int[N]; ans[0] = start;
            for (int i = 1; i < N; i++) ans[i] = ans[i - 1] + step;
            return ans;
        }

        public static Matrix<T>[] Meshgrid(Matrix<T> x, Matrix<T> y)
        {
            Matrix<T> X = new T[y.Numel, x.Numel], Y = new T[y.Numel, x.Numel];
            Matrix<T>[] ans = new Matrix<T>[] { X, Y };
            for (int i = 0; i < y.Numel; i++)
                for (int j = 0; j < x.Numel; j++)
                { Y[i, j] = y[i]; X[i, j] = x[j]; }
            return ans;
        }

        public static Matrix<T> ArrayFun(Func<T,T> fun, Matrix<T> X)
        {
            T[,] f = new T[X.rows, X.cols];
            for (int i = 0; i < X.rows; i++)
                for (int j = 0; j < X.cols; j++)
                    f[i, j] = fun(X[i, j]);
            return f;
        }


        #region comparers

        // Less than
        private bool[,] LT(Matrix<T> m)
        {
            if (rows != m.rows || cols != m.cols)
                throw new Exception("Matrices must be of the same dimensions");
            bool[,] ans = new bool[rows, cols];
            for (int i = 0; i < m.Rows; i++)
            {
                for (int j = 0; j < m.Cols; j++)
                {
                    ans[i, j] = mat[i, j].CompareTo(m.mat[i, j]) < 0;
                }
            }
            return ans;
        }

        // Less than or Equal to
        private bool[,] LTE(Matrix<T> m)
        {
            if (rows != m.rows || cols != m.cols)
                throw new Exception("Matrices must be of the same dimensions");
            bool[,] ans = new bool[rows, cols];
            for (int i = 0; i < m.Rows; i++)
            {
                for (int j = 0; j < m.Cols; j++)
                {
                    ans[i, j] = mat[i, j].CompareTo(m.mat[i, j]) <= 0;
                }
            }
            return ans;
        }

        // Greater than
        private bool[,] GT(Matrix<T> m)
        {
            if (rows != m.rows || cols != m.cols)
                throw new Exception("Matrices must be of the same dimensions");
            bool[,] ans = new bool[rows, cols];
            for (int i = 0; i < m.Rows; i++)
            {
                for (int j = 0; j < m.Cols; j++)
                {
                    ans[i, j] = mat[i, j].CompareTo(m.mat[i, j]) > 0;
                }
            }
            return ans;
        }

        // Greater than or Equal to
        private bool[,] GTE(Matrix<T> m)
        {
            if (rows != m.rows || cols != m.cols)
                throw new Exception("Matrices must be of the same dimensions");
            bool[,] ans = new bool[rows, cols];
            for (int i = 0; i < m.Rows; i++)
            {
                for (int j = 0; j < m.Cols; j++)
                {
                    ans[i, j] = mat[i, j].CompareTo(m.mat[i, j]) >= 0;
                }
            }
            return ans;
        }

        // Equal To
        private bool[,] ET(Matrix<T> m)
        {
            if (rows != m.rows || cols != m.cols)
                throw new Exception("Matrices must be of the same dimensions");
            bool[,] ans = new bool[rows, cols];
            for (int i = 0; i < m.Rows; i++)
            {
                for (int j = 0; j < m.Cols; j++)
                {
                    ans[i, j] = mat[i, j].CompareTo(m.mat[i, j]) == 0;
                }
            }
            return ans;
        }

        // Not Equal To
        private bool[,] NET(Matrix<T> m)
        {
            if (rows != m.rows || cols != m.cols)
                throw new Exception("Matrices must be of the same dimensions");
            bool[,] ans = new bool[rows, cols];
            for (int i = 0; i < m.Rows; i++)
            {
                for (int j = 0; j < m.Cols; j++)
                {
                    ans[i, j] = mat[i, j].CompareTo(m.mat[i, j]) != 0;
                }
            }
            return ans;
        }

        #endregion

        #region OPERATORS

        #region negation
        public static Matrix<T> operator -(Matrix<T> m)
        {
            T[,] ans = new T[m.rows,m.cols];
            for (int i = 0; i < m.rows; i++)
                for (int j = 0; j < m.cols; j++)
                    ans[i, j] = m.mat[i, j].Mult(-1);
            return ans;
        }
        #endregion

        #region Addition

        public static Matrix<T> operator +(Matrix<T> n, Matrix<T> m)
        { return Add(n, m); }
        public static Matrix<T> operator +(T n, Matrix<T> m)
        { return Add(n, m); }
        public static Matrix<T> operator +(Matrix<T> n, T m)
        { return Add(n, m); }

        #endregion

        #region Subtraction

        public static Matrix<T> operator -(Matrix<T> n, Matrix<T> m)
        { return Sub(n, m); }
        public static Matrix<T> operator -(T n, Matrix<T> m)
        { return Sub(n, m); }
        public static Matrix<T> operator -(Matrix<T> n, T m)
        { return Sub(n, m); }

        #endregion

        #region Multiplcation

        public static Matrix<T> operator *(Matrix<T> n, Matrix<T> m)
        { return mult(n, m); }
        public static Matrix<T> operator *(T n, Matrix<T> m)
        { return m.Mult(n); }
        public static Matrix<T> operator *(Matrix<T> n, T m)
        { return n.Mult(m); }

        #endregion

        #region Division

        public static Matrix<T> operator /(Matrix<T> n, Matrix<T> m)
        { return Solve(n, m); }
        public static Matrix<T> operator /(T n, Matrix<T> m)
        { Matrix<T> _n = n;  return _n.Div(m); }
        public static Matrix<T> operator /(Matrix<T> n, T m)
        { return n.Div(m); }

        #endregion

        #region comparer operators
        public static bool[,] operator <(Matrix<T> n, Matrix<T> m)
        { return n.LT(m); }

        public static bool[,] operator >(Matrix<T> n, Matrix<T> m)
        { return n.GT(m); }

        public static bool[,] operator <=(Matrix<T> n, Matrix<T> m)
        { return n.LTE(m); }

        public static bool[,] operator >=(Matrix<T> n, Matrix<T> m)
        { return n.GTE(m); }

        public static bool[,] operator ==(Matrix<T> n, Matrix<T> m)
        { return n.ET(m); }

        public static bool[,] operator !=(Matrix<T> n, Matrix<T> m)
        { return n.NET(m); }
        #endregion

        #endregion
    }

}
